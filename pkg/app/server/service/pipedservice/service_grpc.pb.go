// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: pkg/app/server/service/pipedservice/service.proto

package pipedservice

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PipedServiceClient is the client API for PipedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PipedServiceClient interface {
	// ReportStat is periodically sent to report its realtime status/stats to control-plane.
	// The received stats will be pushed to the metrics collector.
	ReportStat(ctx context.Context, in *ReportStatRequest, opts ...grpc.CallOption) (*ReportStatResponse, error)
	// ReportPipedMeta is sent while starting up to report its metadata
	// such as configured cloud providers.
	ReportPipedMeta(ctx context.Context, in *ReportPipedMetaRequest, opts ...grpc.CallOption) (*ReportPipedMetaResponse, error)
	// ListApplications returns a list of registered applications
	// that should be managed by the requested piped.
	// Disabled applications should not be included in the response.
	// Piped uses this RPC to fetch and sync the application configuration into its local database.
	ListApplications(ctx context.Context, in *ListApplicationsRequest, opts ...grpc.CallOption) (*ListApplicationsResponse, error)
	// ReportApplicationSyncState is used to update the sync status of an application.
	ReportApplicationSyncState(ctx context.Context, in *ReportApplicationSyncStateRequest, opts ...grpc.CallOption) (*ReportApplicationSyncStateResponse, error)
	// ReportApplicationDeployingStatus is used to report whether the specified application is deploying or not.
	ReportApplicationDeployingStatus(ctx context.Context, in *ReportApplicationDeployingStatusRequest, opts ...grpc.CallOption) (*ReportApplicationDeployingStatusResponse, error)
	// ReportApplicationMostRecentDeployment is used to update the basic information about
	// the most recent deployment of a specific application.
	ReportApplicationMostRecentDeployment(ctx context.Context, in *ReportApplicationMostRecentDeploymentRequest, opts ...grpc.CallOption) (*ReportApplicationMostRecentDeploymentResponse, error)
	// GetApplicationMostRecentDeployment returns the most recent deployment of the given application.
	GetApplicationMostRecentDeployment(ctx context.Context, in *GetApplicationMostRecentDeploymentRequest, opts ...grpc.CallOption) (*GetApplicationMostRecentDeploymentResponse, error)
	// GetDeployment returns the deployment for given deployment ID.
	GetDeployment(ctx context.Context, in *GetDeploymentRequest, opts ...grpc.CallOption) (*GetDeploymentResponse, error)
	// ListNotCompletedDeployments returns a list of not completed deployments
	// which are managed by this piped.
	// DeploymentController component uses this RPC to spawns/syncs its local deployment executors.
	ListNotCompletedDeployments(ctx context.Context, in *ListNotCompletedDeploymentsRequest, opts ...grpc.CallOption) (*ListNotCompletedDeploymentsResponse, error)
	// CreateDeployment creates/triggers a new deployment for an application
	// that is managed by this piped.
	// This will be used by DeploymentTrigger component.
	CreateDeployment(ctx context.Context, in *CreateDeploymentRequest, opts ...grpc.CallOption) (*CreateDeploymentResponse, error)
	// ReportDeploymentPlanned is used to update the status
	// of a specific deployment to PLANNED.
	ReportDeploymentPlanned(ctx context.Context, in *ReportDeploymentPlannedRequest, opts ...grpc.CallOption) (*ReportDeploymentPlannedResponse, error)
	// ReportDeploymentStatusChanged is used to update the status
	// of a specific deployment to RUNNING or ROLLING_BACK.
	ReportDeploymentStatusChanged(ctx context.Context, in *ReportDeploymentStatusChangedRequest, opts ...grpc.CallOption) (*ReportDeploymentStatusChangedResponse, error)
	// ReportDeploymentCompleted is used to update the status
	// of a specific deployment to SUCCESS | FAILURE | CANCELLED.
	ReportDeploymentCompleted(ctx context.Context, in *ReportDeploymentCompletedRequest, opts ...grpc.CallOption) (*ReportDeploymentCompletedResponse, error)
	// SaveDeploymentMetadata is used to persist the metadata of a specific deployment.
	// Different value for the same key will overwrite the previous value for that key.
	SaveDeploymentMetadata(ctx context.Context, in *SaveDeploymentMetadataRequest, opts ...grpc.CallOption) (*SaveDeploymentMetadataResponse, error)
	// SaveStageMetadata is used to persist the metadata
	// of a specific stage of a deployment.
	// Different value for the same key will overwrite the previous value for that key.
	SaveStageMetadata(ctx context.Context, in *SaveStageMetadataRequest, opts ...grpc.CallOption) (*SaveStageMetadataResponse, error)
	// ReportStageLogs is used to save the log of a pipeline stage.
	ReportStageLogs(ctx context.Context, in *ReportStageLogsRequest, opts ...grpc.CallOption) (*ReportStageLogsResponse, error)
	// ReportStageLogsFromLastCheckpoint is used to save the full logs from the most recently saved point.
	ReportStageLogsFromLastCheckpoint(ctx context.Context, in *ReportStageLogsFromLastCheckpointRequest, opts ...grpc.CallOption) (*ReportStageLogsFromLastCheckpointResponse, error)
	// ReportStageStatusChanged is used to update the status
	// of a specific stage of a deployment.
	ReportStageStatusChanged(ctx context.Context, in *ReportStageStatusChangedRequest, opts ...grpc.CallOption) (*ReportStageStatusChangedResponse, error)
	// ListUnhandledCommands is periodically called to obtain the commands
	// that should be handled.
	// Whenever an user makes an interaction from WebUI (cancel/approve/sync)
	// a new command with a unique identifier will be generated an saved into the datastore.
	// Piped uses this RPC to list all still-not-handled commands to handle them,
	// then report back the result to server.
	// On other side, the web will periodically check the command status and feedback the result to user.
	// In the future, we may need a solution to remove all old-handled commands from datastore for space.
	ListUnhandledCommands(ctx context.Context, in *ListUnhandledCommandsRequest, opts ...grpc.CallOption) (*ListUnhandledCommandsResponse, error)
	// ReportCommandHandled is called to mark a specific command as handled.
	// The request payload will contain the handle status as well as any additional result data.
	// The handle result should be updated to both datastore and cache (for reading from web).
	ReportCommandHandled(ctx context.Context, in *ReportCommandHandledRequest, opts ...grpc.CallOption) (*ReportCommandHandledResponse, error)
	// ReportApplicationLiveState is periodically sent to correct full state of an application.
	// For kubernetes application, this contains a full tree of its kubernetes resources.
	// The tree data should be written into filestore immediately and then the state in cache should be refreshsed too.
	ReportApplicationLiveState(ctx context.Context, in *ReportApplicationLiveStateRequest, opts ...grpc.CallOption) (*ReportApplicationLiveStateResponse, error)
	// ReportApplicationLiveStateEvents is sent to submit one or multiple events
	// about the changes of application live state.
	// Control plane uses the received events to update the state of application-resource-tree.
	// We want to start by a simple solution at this initial stage of development,
	// so the API server just handles as below:
	// - loads the releated application-resource-tree from the cache
	// - checks and builds new state for the application-resource-tree
	// - updates new state into cache (cache data is for reading while handling web requests)
	// In the future, we may want to redesign the behavior of this RPC by using pubsub/queue pattern.
	// After receiving the events, all of them will be published into a queue immediately,
	// and then another Handler service will pick them inorder to apply to build new state.
	// By that way we can control the traffic to the datastore in a better way.
	ReportApplicationLiveStateEvents(ctx context.Context, in *ReportApplicationLiveStateEventsRequest, opts ...grpc.CallOption) (*ReportApplicationLiveStateEventsResponse, error)
	// GetLatestEvent returns the latest event that meets the given conditions.
	GetLatestEvent(ctx context.Context, in *GetLatestEventRequest, opts ...grpc.CallOption) (*GetLatestEventResponse, error)
	// ListEvents returns a list of Events inside the given range.
	ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (*ListEventsResponse, error)
	// ReportEventHandled marks the given all events as handled.
	// Deprecated. This is only for the old Piped agents.
	ReportEventsHandled(ctx context.Context, in *ReportEventsHandledRequest, opts ...grpc.CallOption) (*ReportEventsHandledResponse, error)
	// ReportEventStatuses reports a status list of events.
	ReportEventStatuses(ctx context.Context, in *ReportEventStatusesRequest, opts ...grpc.CallOption) (*ReportEventStatusesResponse, error)
	// GetLatestAnalysisResult returns the most successful analysis result.
	GetLatestAnalysisResult(ctx context.Context, in *GetLatestAnalysisResultRequest, opts ...grpc.CallOption) (*GetLatestAnalysisResultResponse, error)
	// GetLatestAnalysisResult updates the most successful analysis result.
	PutLatestAnalysisResult(ctx context.Context, in *PutLatestAnalysisResultRequest, opts ...grpc.CallOption) (*PutLatestAnalysisResultResponse, error)
	// GetDesiredVersion returns the desired version of the given Piped.
	GetDesiredVersion(ctx context.Context, in *GetDesiredVersionRequest, opts ...grpc.CallOption) (*GetDesiredVersionResponse, error)
	// UpdateApplicationConfigurations updates application configurations.
	UpdateApplicationConfigurations(ctx context.Context, in *UpdateApplicationConfigurationsRequest, opts ...grpc.CallOption) (*UpdateApplicationConfigurationsResponse, error)
	// ReportLatestUnusedApplicationConfigurations puts the latest configurations of applications that isn't registered yet.
	ReportUnregisteredApplicationConfigurations(ctx context.Context, in *ReportUnregisteredApplicationConfigurationsRequest, opts ...grpc.CallOption) (*ReportUnregisteredApplicationConfigurationsResponse, error)
	// CreateDeploymentChain creates a new deployment chain object and all required commands to
	// trigger deployment for applications in the chain.
	CreateDeploymentChain(ctx context.Context, in *CreateDeploymentChainRequest, opts ...grpc.CallOption) (*CreateDeploymentChainResponse, error)
	// DeploymentPlannable checks the completion and status of the previous block in the deployment chain,
	// only when all the nodes of the previous block are completed with a success status,
	// the nodes of the next block will be treated as processable.
	// In case the previous block of this deployment is finished with FAILURE | CANCELLED status,
	// `cancel` flag will be returned to aware piped to stop this deployment.
	InChainDeploymentPlannable(ctx context.Context, in *InChainDeploymentPlannableRequest, opts ...grpc.CallOption) (*InChainDeploymentPlannableResponse, error)
}

type pipedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPipedServiceClient(cc grpc.ClientConnInterface) PipedServiceClient {
	return &pipedServiceClient{cc}
}

func (c *pipedServiceClient) ReportStat(ctx context.Context, in *ReportStatRequest, opts ...grpc.CallOption) (*ReportStatResponse, error) {
	out := new(ReportStatResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportStat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportPipedMeta(ctx context.Context, in *ReportPipedMetaRequest, opts ...grpc.CallOption) (*ReportPipedMetaResponse, error) {
	out := new(ReportPipedMetaResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportPipedMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ListApplications(ctx context.Context, in *ListApplicationsRequest, opts ...grpc.CallOption) (*ListApplicationsResponse, error) {
	out := new(ListApplicationsResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ListApplications", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportApplicationSyncState(ctx context.Context, in *ReportApplicationSyncStateRequest, opts ...grpc.CallOption) (*ReportApplicationSyncStateResponse, error) {
	out := new(ReportApplicationSyncStateResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportApplicationSyncState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportApplicationDeployingStatus(ctx context.Context, in *ReportApplicationDeployingStatusRequest, opts ...grpc.CallOption) (*ReportApplicationDeployingStatusResponse, error) {
	out := new(ReportApplicationDeployingStatusResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportApplicationDeployingStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportApplicationMostRecentDeployment(ctx context.Context, in *ReportApplicationMostRecentDeploymentRequest, opts ...grpc.CallOption) (*ReportApplicationMostRecentDeploymentResponse, error) {
	out := new(ReportApplicationMostRecentDeploymentResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportApplicationMostRecentDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) GetApplicationMostRecentDeployment(ctx context.Context, in *GetApplicationMostRecentDeploymentRequest, opts ...grpc.CallOption) (*GetApplicationMostRecentDeploymentResponse, error) {
	out := new(GetApplicationMostRecentDeploymentResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/GetApplicationMostRecentDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) GetDeployment(ctx context.Context, in *GetDeploymentRequest, opts ...grpc.CallOption) (*GetDeploymentResponse, error) {
	out := new(GetDeploymentResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/GetDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ListNotCompletedDeployments(ctx context.Context, in *ListNotCompletedDeploymentsRequest, opts ...grpc.CallOption) (*ListNotCompletedDeploymentsResponse, error) {
	out := new(ListNotCompletedDeploymentsResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ListNotCompletedDeployments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) CreateDeployment(ctx context.Context, in *CreateDeploymentRequest, opts ...grpc.CallOption) (*CreateDeploymentResponse, error) {
	out := new(CreateDeploymentResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/CreateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportDeploymentPlanned(ctx context.Context, in *ReportDeploymentPlannedRequest, opts ...grpc.CallOption) (*ReportDeploymentPlannedResponse, error) {
	out := new(ReportDeploymentPlannedResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportDeploymentPlanned", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportDeploymentStatusChanged(ctx context.Context, in *ReportDeploymentStatusChangedRequest, opts ...grpc.CallOption) (*ReportDeploymentStatusChangedResponse, error) {
	out := new(ReportDeploymentStatusChangedResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportDeploymentStatusChanged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportDeploymentCompleted(ctx context.Context, in *ReportDeploymentCompletedRequest, opts ...grpc.CallOption) (*ReportDeploymentCompletedResponse, error) {
	out := new(ReportDeploymentCompletedResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportDeploymentCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) SaveDeploymentMetadata(ctx context.Context, in *SaveDeploymentMetadataRequest, opts ...grpc.CallOption) (*SaveDeploymentMetadataResponse, error) {
	out := new(SaveDeploymentMetadataResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/SaveDeploymentMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) SaveStageMetadata(ctx context.Context, in *SaveStageMetadataRequest, opts ...grpc.CallOption) (*SaveStageMetadataResponse, error) {
	out := new(SaveStageMetadataResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/SaveStageMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportStageLogs(ctx context.Context, in *ReportStageLogsRequest, opts ...grpc.CallOption) (*ReportStageLogsResponse, error) {
	out := new(ReportStageLogsResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportStageLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportStageLogsFromLastCheckpoint(ctx context.Context, in *ReportStageLogsFromLastCheckpointRequest, opts ...grpc.CallOption) (*ReportStageLogsFromLastCheckpointResponse, error) {
	out := new(ReportStageLogsFromLastCheckpointResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportStageLogsFromLastCheckpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportStageStatusChanged(ctx context.Context, in *ReportStageStatusChangedRequest, opts ...grpc.CallOption) (*ReportStageStatusChangedResponse, error) {
	out := new(ReportStageStatusChangedResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportStageStatusChanged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ListUnhandledCommands(ctx context.Context, in *ListUnhandledCommandsRequest, opts ...grpc.CallOption) (*ListUnhandledCommandsResponse, error) {
	out := new(ListUnhandledCommandsResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ListUnhandledCommands", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportCommandHandled(ctx context.Context, in *ReportCommandHandledRequest, opts ...grpc.CallOption) (*ReportCommandHandledResponse, error) {
	out := new(ReportCommandHandledResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportCommandHandled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportApplicationLiveState(ctx context.Context, in *ReportApplicationLiveStateRequest, opts ...grpc.CallOption) (*ReportApplicationLiveStateResponse, error) {
	out := new(ReportApplicationLiveStateResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportApplicationLiveState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportApplicationLiveStateEvents(ctx context.Context, in *ReportApplicationLiveStateEventsRequest, opts ...grpc.CallOption) (*ReportApplicationLiveStateEventsResponse, error) {
	out := new(ReportApplicationLiveStateEventsResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportApplicationLiveStateEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) GetLatestEvent(ctx context.Context, in *GetLatestEventRequest, opts ...grpc.CallOption) (*GetLatestEventResponse, error) {
	out := new(GetLatestEventResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/GetLatestEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (*ListEventsResponse, error) {
	out := new(ListEventsResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ListEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportEventsHandled(ctx context.Context, in *ReportEventsHandledRequest, opts ...grpc.CallOption) (*ReportEventsHandledResponse, error) {
	out := new(ReportEventsHandledResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportEventsHandled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportEventStatuses(ctx context.Context, in *ReportEventStatusesRequest, opts ...grpc.CallOption) (*ReportEventStatusesResponse, error) {
	out := new(ReportEventStatusesResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportEventStatuses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) GetLatestAnalysisResult(ctx context.Context, in *GetLatestAnalysisResultRequest, opts ...grpc.CallOption) (*GetLatestAnalysisResultResponse, error) {
	out := new(GetLatestAnalysisResultResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/GetLatestAnalysisResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) PutLatestAnalysisResult(ctx context.Context, in *PutLatestAnalysisResultRequest, opts ...grpc.CallOption) (*PutLatestAnalysisResultResponse, error) {
	out := new(PutLatestAnalysisResultResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/PutLatestAnalysisResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) GetDesiredVersion(ctx context.Context, in *GetDesiredVersionRequest, opts ...grpc.CallOption) (*GetDesiredVersionResponse, error) {
	out := new(GetDesiredVersionResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/GetDesiredVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) UpdateApplicationConfigurations(ctx context.Context, in *UpdateApplicationConfigurationsRequest, opts ...grpc.CallOption) (*UpdateApplicationConfigurationsResponse, error) {
	out := new(UpdateApplicationConfigurationsResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/UpdateApplicationConfigurations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) ReportUnregisteredApplicationConfigurations(ctx context.Context, in *ReportUnregisteredApplicationConfigurationsRequest, opts ...grpc.CallOption) (*ReportUnregisteredApplicationConfigurationsResponse, error) {
	out := new(ReportUnregisteredApplicationConfigurationsResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/ReportUnregisteredApplicationConfigurations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) CreateDeploymentChain(ctx context.Context, in *CreateDeploymentChainRequest, opts ...grpc.CallOption) (*CreateDeploymentChainResponse, error) {
	out := new(CreateDeploymentChainResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/CreateDeploymentChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipedServiceClient) InChainDeploymentPlannable(ctx context.Context, in *InChainDeploymentPlannableRequest, opts ...grpc.CallOption) (*InChainDeploymentPlannableResponse, error) {
	out := new(InChainDeploymentPlannableResponse)
	err := c.cc.Invoke(ctx, "/grpc.service.pipedservice.PipedService/InChainDeploymentPlannable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PipedServiceServer is the server API for PipedService service.
// All implementations must embed UnimplementedPipedServiceServer
// for forward compatibility
type PipedServiceServer interface {
	// ReportStat is periodically sent to report its realtime status/stats to control-plane.
	// The received stats will be pushed to the metrics collector.
	ReportStat(context.Context, *ReportStatRequest) (*ReportStatResponse, error)
	// ReportPipedMeta is sent while starting up to report its metadata
	// such as configured cloud providers.
	ReportPipedMeta(context.Context, *ReportPipedMetaRequest) (*ReportPipedMetaResponse, error)
	// ListApplications returns a list of registered applications
	// that should be managed by the requested piped.
	// Disabled applications should not be included in the response.
	// Piped uses this RPC to fetch and sync the application configuration into its local database.
	ListApplications(context.Context, *ListApplicationsRequest) (*ListApplicationsResponse, error)
	// ReportApplicationSyncState is used to update the sync status of an application.
	ReportApplicationSyncState(context.Context, *ReportApplicationSyncStateRequest) (*ReportApplicationSyncStateResponse, error)
	// ReportApplicationDeployingStatus is used to report whether the specified application is deploying or not.
	ReportApplicationDeployingStatus(context.Context, *ReportApplicationDeployingStatusRequest) (*ReportApplicationDeployingStatusResponse, error)
	// ReportApplicationMostRecentDeployment is used to update the basic information about
	// the most recent deployment of a specific application.
	ReportApplicationMostRecentDeployment(context.Context, *ReportApplicationMostRecentDeploymentRequest) (*ReportApplicationMostRecentDeploymentResponse, error)
	// GetApplicationMostRecentDeployment returns the most recent deployment of the given application.
	GetApplicationMostRecentDeployment(context.Context, *GetApplicationMostRecentDeploymentRequest) (*GetApplicationMostRecentDeploymentResponse, error)
	// GetDeployment returns the deployment for given deployment ID.
	GetDeployment(context.Context, *GetDeploymentRequest) (*GetDeploymentResponse, error)
	// ListNotCompletedDeployments returns a list of not completed deployments
	// which are managed by this piped.
	// DeploymentController component uses this RPC to spawns/syncs its local deployment executors.
	ListNotCompletedDeployments(context.Context, *ListNotCompletedDeploymentsRequest) (*ListNotCompletedDeploymentsResponse, error)
	// CreateDeployment creates/triggers a new deployment for an application
	// that is managed by this piped.
	// This will be used by DeploymentTrigger component.
	CreateDeployment(context.Context, *CreateDeploymentRequest) (*CreateDeploymentResponse, error)
	// ReportDeploymentPlanned is used to update the status
	// of a specific deployment to PLANNED.
	ReportDeploymentPlanned(context.Context, *ReportDeploymentPlannedRequest) (*ReportDeploymentPlannedResponse, error)
	// ReportDeploymentStatusChanged is used to update the status
	// of a specific deployment to RUNNING or ROLLING_BACK.
	ReportDeploymentStatusChanged(context.Context, *ReportDeploymentStatusChangedRequest) (*ReportDeploymentStatusChangedResponse, error)
	// ReportDeploymentCompleted is used to update the status
	// of a specific deployment to SUCCESS | FAILURE | CANCELLED.
	ReportDeploymentCompleted(context.Context, *ReportDeploymentCompletedRequest) (*ReportDeploymentCompletedResponse, error)
	// SaveDeploymentMetadata is used to persist the metadata of a specific deployment.
	// Different value for the same key will overwrite the previous value for that key.
	SaveDeploymentMetadata(context.Context, *SaveDeploymentMetadataRequest) (*SaveDeploymentMetadataResponse, error)
	// SaveStageMetadata is used to persist the metadata
	// of a specific stage of a deployment.
	// Different value for the same key will overwrite the previous value for that key.
	SaveStageMetadata(context.Context, *SaveStageMetadataRequest) (*SaveStageMetadataResponse, error)
	// ReportStageLogs is used to save the log of a pipeline stage.
	ReportStageLogs(context.Context, *ReportStageLogsRequest) (*ReportStageLogsResponse, error)
	// ReportStageLogsFromLastCheckpoint is used to save the full logs from the most recently saved point.
	ReportStageLogsFromLastCheckpoint(context.Context, *ReportStageLogsFromLastCheckpointRequest) (*ReportStageLogsFromLastCheckpointResponse, error)
	// ReportStageStatusChanged is used to update the status
	// of a specific stage of a deployment.
	ReportStageStatusChanged(context.Context, *ReportStageStatusChangedRequest) (*ReportStageStatusChangedResponse, error)
	// ListUnhandledCommands is periodically called to obtain the commands
	// that should be handled.
	// Whenever an user makes an interaction from WebUI (cancel/approve/sync)
	// a new command with a unique identifier will be generated an saved into the datastore.
	// Piped uses this RPC to list all still-not-handled commands to handle them,
	// then report back the result to server.
	// On other side, the web will periodically check the command status and feedback the result to user.
	// In the future, we may need a solution to remove all old-handled commands from datastore for space.
	ListUnhandledCommands(context.Context, *ListUnhandledCommandsRequest) (*ListUnhandledCommandsResponse, error)
	// ReportCommandHandled is called to mark a specific command as handled.
	// The request payload will contain the handle status as well as any additional result data.
	// The handle result should be updated to both datastore and cache (for reading from web).
	ReportCommandHandled(context.Context, *ReportCommandHandledRequest) (*ReportCommandHandledResponse, error)
	// ReportApplicationLiveState is periodically sent to correct full state of an application.
	// For kubernetes application, this contains a full tree of its kubernetes resources.
	// The tree data should be written into filestore immediately and then the state in cache should be refreshsed too.
	ReportApplicationLiveState(context.Context, *ReportApplicationLiveStateRequest) (*ReportApplicationLiveStateResponse, error)
	// ReportApplicationLiveStateEvents is sent to submit one or multiple events
	// about the changes of application live state.
	// Control plane uses the received events to update the state of application-resource-tree.
	// We want to start by a simple solution at this initial stage of development,
	// so the API server just handles as below:
	// - loads the releated application-resource-tree from the cache
	// - checks and builds new state for the application-resource-tree
	// - updates new state into cache (cache data is for reading while handling web requests)
	// In the future, we may want to redesign the behavior of this RPC by using pubsub/queue pattern.
	// After receiving the events, all of them will be published into a queue immediately,
	// and then another Handler service will pick them inorder to apply to build new state.
	// By that way we can control the traffic to the datastore in a better way.
	ReportApplicationLiveStateEvents(context.Context, *ReportApplicationLiveStateEventsRequest) (*ReportApplicationLiveStateEventsResponse, error)
	// GetLatestEvent returns the latest event that meets the given conditions.
	GetLatestEvent(context.Context, *GetLatestEventRequest) (*GetLatestEventResponse, error)
	// ListEvents returns a list of Events inside the given range.
	ListEvents(context.Context, *ListEventsRequest) (*ListEventsResponse, error)
	// ReportEventHandled marks the given all events as handled.
	// Deprecated. This is only for the old Piped agents.
	ReportEventsHandled(context.Context, *ReportEventsHandledRequest) (*ReportEventsHandledResponse, error)
	// ReportEventStatuses reports a status list of events.
	ReportEventStatuses(context.Context, *ReportEventStatusesRequest) (*ReportEventStatusesResponse, error)
	// GetLatestAnalysisResult returns the most successful analysis result.
	GetLatestAnalysisResult(context.Context, *GetLatestAnalysisResultRequest) (*GetLatestAnalysisResultResponse, error)
	// GetLatestAnalysisResult updates the most successful analysis result.
	PutLatestAnalysisResult(context.Context, *PutLatestAnalysisResultRequest) (*PutLatestAnalysisResultResponse, error)
	// GetDesiredVersion returns the desired version of the given Piped.
	GetDesiredVersion(context.Context, *GetDesiredVersionRequest) (*GetDesiredVersionResponse, error)
	// UpdateApplicationConfigurations updates application configurations.
	UpdateApplicationConfigurations(context.Context, *UpdateApplicationConfigurationsRequest) (*UpdateApplicationConfigurationsResponse, error)
	// ReportLatestUnusedApplicationConfigurations puts the latest configurations of applications that isn't registered yet.
	ReportUnregisteredApplicationConfigurations(context.Context, *ReportUnregisteredApplicationConfigurationsRequest) (*ReportUnregisteredApplicationConfigurationsResponse, error)
	// CreateDeploymentChain creates a new deployment chain object and all required commands to
	// trigger deployment for applications in the chain.
	CreateDeploymentChain(context.Context, *CreateDeploymentChainRequest) (*CreateDeploymentChainResponse, error)
	// DeploymentPlannable checks the completion and status of the previous block in the deployment chain,
	// only when all the nodes of the previous block are completed with a success status,
	// the nodes of the next block will be treated as processable.
	// In case the previous block of this deployment is finished with FAILURE | CANCELLED status,
	// `cancel` flag will be returned to aware piped to stop this deployment.
	InChainDeploymentPlannable(context.Context, *InChainDeploymentPlannableRequest) (*InChainDeploymentPlannableResponse, error)
	mustEmbedUnimplementedPipedServiceServer()
}

// UnimplementedPipedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPipedServiceServer struct {
}

func (UnimplementedPipedServiceServer) ReportStat(context.Context, *ReportStatRequest) (*ReportStatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportStat not implemented")
}
func (UnimplementedPipedServiceServer) ReportPipedMeta(context.Context, *ReportPipedMetaRequest) (*ReportPipedMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportPipedMeta not implemented")
}
func (UnimplementedPipedServiceServer) ListApplications(context.Context, *ListApplicationsRequest) (*ListApplicationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListApplications not implemented")
}
func (UnimplementedPipedServiceServer) ReportApplicationSyncState(context.Context, *ReportApplicationSyncStateRequest) (*ReportApplicationSyncStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportApplicationSyncState not implemented")
}
func (UnimplementedPipedServiceServer) ReportApplicationDeployingStatus(context.Context, *ReportApplicationDeployingStatusRequest) (*ReportApplicationDeployingStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportApplicationDeployingStatus not implemented")
}
func (UnimplementedPipedServiceServer) ReportApplicationMostRecentDeployment(context.Context, *ReportApplicationMostRecentDeploymentRequest) (*ReportApplicationMostRecentDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportApplicationMostRecentDeployment not implemented")
}
func (UnimplementedPipedServiceServer) GetApplicationMostRecentDeployment(context.Context, *GetApplicationMostRecentDeploymentRequest) (*GetApplicationMostRecentDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApplicationMostRecentDeployment not implemented")
}
func (UnimplementedPipedServiceServer) GetDeployment(context.Context, *GetDeploymentRequest) (*GetDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeployment not implemented")
}
func (UnimplementedPipedServiceServer) ListNotCompletedDeployments(context.Context, *ListNotCompletedDeploymentsRequest) (*ListNotCompletedDeploymentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotCompletedDeployments not implemented")
}
func (UnimplementedPipedServiceServer) CreateDeployment(context.Context, *CreateDeploymentRequest) (*CreateDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDeployment not implemented")
}
func (UnimplementedPipedServiceServer) ReportDeploymentPlanned(context.Context, *ReportDeploymentPlannedRequest) (*ReportDeploymentPlannedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportDeploymentPlanned not implemented")
}
func (UnimplementedPipedServiceServer) ReportDeploymentStatusChanged(context.Context, *ReportDeploymentStatusChangedRequest) (*ReportDeploymentStatusChangedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportDeploymentStatusChanged not implemented")
}
func (UnimplementedPipedServiceServer) ReportDeploymentCompleted(context.Context, *ReportDeploymentCompletedRequest) (*ReportDeploymentCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportDeploymentCompleted not implemented")
}
func (UnimplementedPipedServiceServer) SaveDeploymentMetadata(context.Context, *SaveDeploymentMetadataRequest) (*SaveDeploymentMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveDeploymentMetadata not implemented")
}
func (UnimplementedPipedServiceServer) SaveStageMetadata(context.Context, *SaveStageMetadataRequest) (*SaveStageMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveStageMetadata not implemented")
}
func (UnimplementedPipedServiceServer) ReportStageLogs(context.Context, *ReportStageLogsRequest) (*ReportStageLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportStageLogs not implemented")
}
func (UnimplementedPipedServiceServer) ReportStageLogsFromLastCheckpoint(context.Context, *ReportStageLogsFromLastCheckpointRequest) (*ReportStageLogsFromLastCheckpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportStageLogsFromLastCheckpoint not implemented")
}
func (UnimplementedPipedServiceServer) ReportStageStatusChanged(context.Context, *ReportStageStatusChangedRequest) (*ReportStageStatusChangedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportStageStatusChanged not implemented")
}
func (UnimplementedPipedServiceServer) ListUnhandledCommands(context.Context, *ListUnhandledCommandsRequest) (*ListUnhandledCommandsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUnhandledCommands not implemented")
}
func (UnimplementedPipedServiceServer) ReportCommandHandled(context.Context, *ReportCommandHandledRequest) (*ReportCommandHandledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportCommandHandled not implemented")
}
func (UnimplementedPipedServiceServer) ReportApplicationLiveState(context.Context, *ReportApplicationLiveStateRequest) (*ReportApplicationLiveStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportApplicationLiveState not implemented")
}
func (UnimplementedPipedServiceServer) ReportApplicationLiveStateEvents(context.Context, *ReportApplicationLiveStateEventsRequest) (*ReportApplicationLiveStateEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportApplicationLiveStateEvents not implemented")
}
func (UnimplementedPipedServiceServer) GetLatestEvent(context.Context, *GetLatestEventRequest) (*GetLatestEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestEvent not implemented")
}
func (UnimplementedPipedServiceServer) ListEvents(context.Context, *ListEventsRequest) (*ListEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEvents not implemented")
}
func (UnimplementedPipedServiceServer) ReportEventsHandled(context.Context, *ReportEventsHandledRequest) (*ReportEventsHandledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportEventsHandled not implemented")
}
func (UnimplementedPipedServiceServer) ReportEventStatuses(context.Context, *ReportEventStatusesRequest) (*ReportEventStatusesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportEventStatuses not implemented")
}
func (UnimplementedPipedServiceServer) GetLatestAnalysisResult(context.Context, *GetLatestAnalysisResultRequest) (*GetLatestAnalysisResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestAnalysisResult not implemented")
}
func (UnimplementedPipedServiceServer) PutLatestAnalysisResult(context.Context, *PutLatestAnalysisResultRequest) (*PutLatestAnalysisResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutLatestAnalysisResult not implemented")
}
func (UnimplementedPipedServiceServer) GetDesiredVersion(context.Context, *GetDesiredVersionRequest) (*GetDesiredVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDesiredVersion not implemented")
}
func (UnimplementedPipedServiceServer) UpdateApplicationConfigurations(context.Context, *UpdateApplicationConfigurationsRequest) (*UpdateApplicationConfigurationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApplicationConfigurations not implemented")
}
func (UnimplementedPipedServiceServer) ReportUnregisteredApplicationConfigurations(context.Context, *ReportUnregisteredApplicationConfigurationsRequest) (*ReportUnregisteredApplicationConfigurationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportUnregisteredApplicationConfigurations not implemented")
}
func (UnimplementedPipedServiceServer) CreateDeploymentChain(context.Context, *CreateDeploymentChainRequest) (*CreateDeploymentChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDeploymentChain not implemented")
}
func (UnimplementedPipedServiceServer) InChainDeploymentPlannable(context.Context, *InChainDeploymentPlannableRequest) (*InChainDeploymentPlannableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InChainDeploymentPlannable not implemented")
}
func (UnimplementedPipedServiceServer) mustEmbedUnimplementedPipedServiceServer() {}

// UnsafePipedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PipedServiceServer will
// result in compilation errors.
type UnsafePipedServiceServer interface {
	mustEmbedUnimplementedPipedServiceServer()
}

func RegisterPipedServiceServer(s grpc.ServiceRegistrar, srv PipedServiceServer) {
	s.RegisterService(&PipedService_ServiceDesc, srv)
}

func _PipedService_ReportStat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportStatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportStat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportStat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportStat(ctx, req.(*ReportStatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportPipedMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportPipedMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportPipedMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportPipedMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportPipedMeta(ctx, req.(*ReportPipedMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ListApplications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListApplicationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ListApplications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ListApplications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ListApplications(ctx, req.(*ListApplicationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportApplicationSyncState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportApplicationSyncStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportApplicationSyncState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportApplicationSyncState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportApplicationSyncState(ctx, req.(*ReportApplicationSyncStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportApplicationDeployingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportApplicationDeployingStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportApplicationDeployingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportApplicationDeployingStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportApplicationDeployingStatus(ctx, req.(*ReportApplicationDeployingStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportApplicationMostRecentDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportApplicationMostRecentDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportApplicationMostRecentDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportApplicationMostRecentDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportApplicationMostRecentDeployment(ctx, req.(*ReportApplicationMostRecentDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_GetApplicationMostRecentDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApplicationMostRecentDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).GetApplicationMostRecentDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/GetApplicationMostRecentDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).GetApplicationMostRecentDeployment(ctx, req.(*GetApplicationMostRecentDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_GetDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).GetDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/GetDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).GetDeployment(ctx, req.(*GetDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ListNotCompletedDeployments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotCompletedDeploymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ListNotCompletedDeployments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ListNotCompletedDeployments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ListNotCompletedDeployments(ctx, req.(*ListNotCompletedDeploymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_CreateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).CreateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/CreateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).CreateDeployment(ctx, req.(*CreateDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportDeploymentPlanned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportDeploymentPlannedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportDeploymentPlanned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportDeploymentPlanned",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportDeploymentPlanned(ctx, req.(*ReportDeploymentPlannedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportDeploymentStatusChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportDeploymentStatusChangedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportDeploymentStatusChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportDeploymentStatusChanged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportDeploymentStatusChanged(ctx, req.(*ReportDeploymentStatusChangedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportDeploymentCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportDeploymentCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportDeploymentCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportDeploymentCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportDeploymentCompleted(ctx, req.(*ReportDeploymentCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_SaveDeploymentMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveDeploymentMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).SaveDeploymentMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/SaveDeploymentMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).SaveDeploymentMetadata(ctx, req.(*SaveDeploymentMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_SaveStageMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveStageMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).SaveStageMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/SaveStageMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).SaveStageMetadata(ctx, req.(*SaveStageMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportStageLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportStageLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportStageLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportStageLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportStageLogs(ctx, req.(*ReportStageLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportStageLogsFromLastCheckpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportStageLogsFromLastCheckpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportStageLogsFromLastCheckpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportStageLogsFromLastCheckpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportStageLogsFromLastCheckpoint(ctx, req.(*ReportStageLogsFromLastCheckpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportStageStatusChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportStageStatusChangedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportStageStatusChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportStageStatusChanged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportStageStatusChanged(ctx, req.(*ReportStageStatusChangedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ListUnhandledCommands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUnhandledCommandsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ListUnhandledCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ListUnhandledCommands",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ListUnhandledCommands(ctx, req.(*ListUnhandledCommandsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportCommandHandled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportCommandHandledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportCommandHandled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportCommandHandled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportCommandHandled(ctx, req.(*ReportCommandHandledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportApplicationLiveState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportApplicationLiveStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportApplicationLiveState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportApplicationLiveState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportApplicationLiveState(ctx, req.(*ReportApplicationLiveStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportApplicationLiveStateEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportApplicationLiveStateEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportApplicationLiveStateEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportApplicationLiveStateEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportApplicationLiveStateEvents(ctx, req.(*ReportApplicationLiveStateEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_GetLatestEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).GetLatestEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/GetLatestEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).GetLatestEvent(ctx, req.(*GetLatestEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ListEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ListEvents(ctx, req.(*ListEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportEventsHandled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportEventsHandledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportEventsHandled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportEventsHandled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportEventsHandled(ctx, req.(*ReportEventsHandledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportEventStatuses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportEventStatusesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportEventStatuses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportEventStatuses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportEventStatuses(ctx, req.(*ReportEventStatusesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_GetLatestAnalysisResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestAnalysisResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).GetLatestAnalysisResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/GetLatestAnalysisResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).GetLatestAnalysisResult(ctx, req.(*GetLatestAnalysisResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_PutLatestAnalysisResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutLatestAnalysisResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).PutLatestAnalysisResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/PutLatestAnalysisResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).PutLatestAnalysisResult(ctx, req.(*PutLatestAnalysisResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_GetDesiredVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDesiredVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).GetDesiredVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/GetDesiredVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).GetDesiredVersion(ctx, req.(*GetDesiredVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_UpdateApplicationConfigurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateApplicationConfigurationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).UpdateApplicationConfigurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/UpdateApplicationConfigurations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).UpdateApplicationConfigurations(ctx, req.(*UpdateApplicationConfigurationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_ReportUnregisteredApplicationConfigurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportUnregisteredApplicationConfigurationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).ReportUnregisteredApplicationConfigurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/ReportUnregisteredApplicationConfigurations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).ReportUnregisteredApplicationConfigurations(ctx, req.(*ReportUnregisteredApplicationConfigurationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_CreateDeploymentChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeploymentChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).CreateDeploymentChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/CreateDeploymentChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).CreateDeploymentChain(ctx, req.(*CreateDeploymentChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipedService_InChainDeploymentPlannable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InChainDeploymentPlannableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipedServiceServer).InChainDeploymentPlannable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.service.pipedservice.PipedService/InChainDeploymentPlannable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipedServiceServer).InChainDeploymentPlannable(ctx, req.(*InChainDeploymentPlannableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PipedService_ServiceDesc is the grpc.ServiceDesc for PipedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PipedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.service.pipedservice.PipedService",
	HandlerType: (*PipedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportStat",
			Handler:    _PipedService_ReportStat_Handler,
		},
		{
			MethodName: "ReportPipedMeta",
			Handler:    _PipedService_ReportPipedMeta_Handler,
		},
		{
			MethodName: "ListApplications",
			Handler:    _PipedService_ListApplications_Handler,
		},
		{
			MethodName: "ReportApplicationSyncState",
			Handler:    _PipedService_ReportApplicationSyncState_Handler,
		},
		{
			MethodName: "ReportApplicationDeployingStatus",
			Handler:    _PipedService_ReportApplicationDeployingStatus_Handler,
		},
		{
			MethodName: "ReportApplicationMostRecentDeployment",
			Handler:    _PipedService_ReportApplicationMostRecentDeployment_Handler,
		},
		{
			MethodName: "GetApplicationMostRecentDeployment",
			Handler:    _PipedService_GetApplicationMostRecentDeployment_Handler,
		},
		{
			MethodName: "GetDeployment",
			Handler:    _PipedService_GetDeployment_Handler,
		},
		{
			MethodName: "ListNotCompletedDeployments",
			Handler:    _PipedService_ListNotCompletedDeployments_Handler,
		},
		{
			MethodName: "CreateDeployment",
			Handler:    _PipedService_CreateDeployment_Handler,
		},
		{
			MethodName: "ReportDeploymentPlanned",
			Handler:    _PipedService_ReportDeploymentPlanned_Handler,
		},
		{
			MethodName: "ReportDeploymentStatusChanged",
			Handler:    _PipedService_ReportDeploymentStatusChanged_Handler,
		},
		{
			MethodName: "ReportDeploymentCompleted",
			Handler:    _PipedService_ReportDeploymentCompleted_Handler,
		},
		{
			MethodName: "SaveDeploymentMetadata",
			Handler:    _PipedService_SaveDeploymentMetadata_Handler,
		},
		{
			MethodName: "SaveStageMetadata",
			Handler:    _PipedService_SaveStageMetadata_Handler,
		},
		{
			MethodName: "ReportStageLogs",
			Handler:    _PipedService_ReportStageLogs_Handler,
		},
		{
			MethodName: "ReportStageLogsFromLastCheckpoint",
			Handler:    _PipedService_ReportStageLogsFromLastCheckpoint_Handler,
		},
		{
			MethodName: "ReportStageStatusChanged",
			Handler:    _PipedService_ReportStageStatusChanged_Handler,
		},
		{
			MethodName: "ListUnhandledCommands",
			Handler:    _PipedService_ListUnhandledCommands_Handler,
		},
		{
			MethodName: "ReportCommandHandled",
			Handler:    _PipedService_ReportCommandHandled_Handler,
		},
		{
			MethodName: "ReportApplicationLiveState",
			Handler:    _PipedService_ReportApplicationLiveState_Handler,
		},
		{
			MethodName: "ReportApplicationLiveStateEvents",
			Handler:    _PipedService_ReportApplicationLiveStateEvents_Handler,
		},
		{
			MethodName: "GetLatestEvent",
			Handler:    _PipedService_GetLatestEvent_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _PipedService_ListEvents_Handler,
		},
		{
			MethodName: "ReportEventsHandled",
			Handler:    _PipedService_ReportEventsHandled_Handler,
		},
		{
			MethodName: "ReportEventStatuses",
			Handler:    _PipedService_ReportEventStatuses_Handler,
		},
		{
			MethodName: "GetLatestAnalysisResult",
			Handler:    _PipedService_GetLatestAnalysisResult_Handler,
		},
		{
			MethodName: "PutLatestAnalysisResult",
			Handler:    _PipedService_PutLatestAnalysisResult_Handler,
		},
		{
			MethodName: "GetDesiredVersion",
			Handler:    _PipedService_GetDesiredVersion_Handler,
		},
		{
			MethodName: "UpdateApplicationConfigurations",
			Handler:    _PipedService_UpdateApplicationConfigurations_Handler,
		},
		{
			MethodName: "ReportUnregisteredApplicationConfigurations",
			Handler:    _PipedService_ReportUnregisteredApplicationConfigurations_Handler,
		},
		{
			MethodName: "CreateDeploymentChain",
			Handler:    _PipedService_CreateDeploymentChain_Handler,
		},
		{
			MethodName: "InChainDeploymentPlannable",
			Handler:    _PipedService_InChainDeploymentPlannable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/app/server/service/pipedservice/service.proto",
}
