// Copyright 2024 The PipeCD Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package initialize

import (
	"errors"
	"fmt"

	"github.com/pipe-cd/pipecd/pkg/app/pipectl/cmd/initialize/prompt"
	"github.com/pipe-cd/pipecd/pkg/config"
)

// Use genericConfigs in order to simplify using the GenericApplicationSpec and keep the order as we want.
type genericKubernetesApplicationSpec struct {
	Name        string                           `json:"name"`
	Input       config.KubernetesDeploymentInput `json:"input"`
	Description string                           `json:"description,omitempty"`
}

func generateKubernetesConfig(p prompt.Prompt) (*genericConfig, error) {
	// inputs
	var (
		appName         string
		manifestManager string
	)

	const (
		// select how to manage manifests
		kustomize string = "0" // for Kustomize
		helm      string = "1" // for Helm
	)

	inputs := []prompt.Input{
		{
			Message:       "Name of the application",
			TargetPointer: &appName,
			Required:      true,
		},
		{
			Message:       fmt.Sprintf("How to manage manifests? [%s]Kustomize [%s]Helm", kustomize, helm),
			TargetPointer: &manifestManager,
			Required:      true,
		},
	}

	err := p.RunSlice(inputs)
	if err != nil {
		return nil, err
	}

	var deploymentInput *config.KubernetesDeploymentInput
	switch manifestManager {
	case kustomize:
		deploymentInput, err = kustomizeInput(p)
	case helm:
		deploymentInput, err = helmImput(p)
	default:
		return nil, errors.New("invalid number")
	}
	if err != nil {
		return nil, err
	}

	spec := &genericKubernetesApplicationSpec{
		Name:        appName,
		Input:       *deploymentInput,
		Description: "Generated by `pipectl init`. See https://pipecd.dev/docs/user-guide/configuration-reference/ for more.",
	}

	return &genericConfig{
		Kind:            config.KindKubernetesApp,
		APIVersion:      config.VersionV1Beta1,
		ApplicationSpec: spec,
	}, nil
}

// Genarate a KubernetesDeploymentInput for Kustomize
func kustomizeInput(p prompt.Prompt) (*config.KubernetesDeploymentInput, error) {
	var (
		kustomizeVersion string
	)
	inputs := []prompt.Input{
		{
			Message:       "Kustomize version",
			TargetPointer: &kustomizeVersion,
			Required:      false,
		},
	}

	err := p.RunSlice(inputs)
	if err != nil {
		return nil, err
	}

	deploymentInput := &config.KubernetesDeploymentInput{
		KustomizeVersion: kustomizeVersion,
	}

	return deploymentInput, nil
}

func helmImput(p prompt.Prompt) (*config.KubernetesDeploymentInput, error) {
	var (
		helmVersion string

		// remote chart
		chartRepository string
		chartName       string
		chartVersion    string
		// local chart
		chartPath string

		// helm options
		releaseName string
		valueFiles  []string
	)

	basicInputs := []prompt.Input{
		{
			Message:       "Helm version",
			TargetPointer: &helmVersion,
			Required:      false,
		},
		{
			Message:       "Helm Chart Repository (if empty, use local chart)",
			TargetPointer: &chartRepository,
			Required:      false,
		},
	}

	// If chartRepository is not empty, use remote chart
	remoteChartInputs := []prompt.Input{
		{
			Message:       "Name of the Helm Chart",
			TargetPointer: &chartName,
			Required:      true,
		},
		{
			Message:       "Version of the Helm Chart",
			TargetPointer: &chartVersion,
			Required:      true,
		},
	}

	// If chartRepository is empty, use local chart
	localChartInputs := []prompt.Input{
		{
			Message:       "Relative path from the repository root to the chart directory",
			TargetPointer: &chartPath,
			Required:      true,
		},
	}

	// Helm options
	helmOptionsInputs := []prompt.Input{
		{
			Message:       "Release name of helm deployment",
			TargetPointer: &releaseName,
			Required:      false,
		},
		{
			Message:       "Value files (separated by space)",
			TargetPointer: &valueFiles,
			Required:      false,
		},
	}

	err := p.RunSlice(basicInputs)
	if err != nil {
		return nil, err
	}

	if len(chartRepository) > 0 {
		// Use remote chart
		err = p.RunSlice(remoteChartInputs)
		if err != nil {
			return nil, err
		}
	} else {
		// Use local chart
		err = p.RunSlice(localChartInputs)
		if err != nil {
			return nil, err
		}
	}

	err = p.RunSlice(helmOptionsInputs)
	if err != nil {
		return nil, err
	}

	deploymentInput := &config.KubernetesDeploymentInput{
		HelmChart: &config.InputHelmChart{
			Repository: chartRepository,
			Name:       chartName,
			Version:    chartVersion,
			Path:       chartPath,
		},
		HelmOptions: &config.InputHelmOptions{
			ReleaseName: releaseName,
			ValueFiles:  valueFiles,
		},
		HelmVersion: helmVersion,
	}

	return deploymentInput, nil
}
