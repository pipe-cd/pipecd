// Copyright 2024 The PipeCD Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package initialize

import (
	"fmt"
	"time"

	"github.com/pipe-cd/pipecd/pkg/app/pipectl/cmd/initialize/prompt"
	"github.com/pipe-cd/pipecd/pkg/config"
	"github.com/pipe-cd/pipecd/pkg/model"
)

// Use genericConfigs in order to simplify using the GenericApplicationSpec and keep the order as we want.
type genericECSApplicationSpec struct {
	Name        string                    `json:"name"`
	Input       config.ECSDeploymentInput `json:"input"`
	Pipeline    genericDeploymentPipeline `json:"pipeline,omitempty"`
	Description string                    `json:"description,omitempty"`
}

func generateECSConfig(p prompt.Prompt) (*genericConfig, error) {
	// inputs
	var (
		appName        string
		serviceDefFile string
		taskDefFile    string

		deploymentStrategy string
	)

	const (
		deploymentStrategyQuickSync = "0"
		deploymentStrategyCanary    = "1"
		deploymentStrategyBlueGreen = "2"
	)

	inputs := []prompt.Input{
		{
			Message:       "Name of the application",
			TargetPointer: &appName,
			Required:      true,
		},
		{
			Message:       "Name of the service definition file (e.g. serviceDef.yaml)",
			TargetPointer: &serviceDefFile,
			Required:      true,
		},
		{
			Message:       "Name of the task definition file (e.g. taskDef.yaml)",
			TargetPointer: &taskDefFile,
			Required:      true,
		},
		{
			Message:       fmt.Sprintf("Deployment strategy [%s]QuickSync [%s]Canary [%s]BlueGreen", deploymentStrategyQuickSync, deploymentStrategyCanary, deploymentStrategyBlueGreen),
			TargetPointer: &deploymentStrategy,
			Required:      true,
		},
	}

	err := p.RunSlice(inputs)
	if err != nil {
		return nil, err
	}

	var in *config.ECSDeploymentInput
	var pipeline *genericDeploymentPipeline
	switch deploymentStrategy {
	case deploymentStrategyQuickSync:
		in, err = inputQuickSync(&p)
	case deploymentStrategyCanary:
		in, pipeline, err = inputCanary(&p)
	case deploymentStrategyBlueGreen:
		in, pipeline, err = inputBlueGreen(&p)
	default:
		return nil, fmt.Errorf("invalid deployment strategy: %s", deploymentStrategy)
	}
	if err != nil {
		return nil, err
	}

	in.ServiceDefinitionFile = serviceDefFile
	in.TaskDefinitionFile = taskDefFile

	spec := &genericECSApplicationSpec{
		Name:        appName,
		Input:       *in,
		Description: "Generated by `pipectl init`. See https://pipecd.dev/docs/user-guide/configuration-reference/ for more.",
	}
	if pipeline != nil {
		spec.Pipeline = *pipeline
	}

	return &genericConfig{
		Kind:            config.KindECSApp,
		APIVersion:      config.VersionV1Beta1,
		ApplicationSpec: spec,
	}, nil
}

func inputQuickSync(p *prompt.Prompt) (*config.ECSDeploymentInput, error) {
	tg, err := inputTargetGroup(p, "")
	if err != nil {
		return nil, err
	}

	return &config.ECSDeploymentInput{
		TargetGroups: config.ECSTargetGroups{
			Primary: tg,
		},
	}, nil
}

func inputCanary(p *prompt.Prompt) (*config.ECSDeploymentInput, *genericDeploymentPipeline, error) {
	// target groups configs
	primaryTarget, err := inputTargetGroup(p, "(primary TaskSet)")
	if err != nil {
		return nil, nil, err
	}

	canaryTarget, err := inputTargetGroup(p, "(canary TaskSet)")
	if err != nil {
		return nil, nil, err
	}

	deploymentInput := config.ECSDeploymentInput{
		TargetGroups: config.ECSTargetGroups{
			Primary: primaryTarget,
			Canary:  canaryTarget,
		},
	}

	// pipeline configs
	var (
		canaryTrafficPercent int = 10
	)
	inputs := []prompt.Input{
		{
			Message:       fmt.Sprintf("Percentage of traffic to canary (default:%d)", canaryTrafficPercent),
			TargetPointer: &canaryTrafficPercent,
			Required:      false,
		},
	}

	err = p.RunSlice(inputs)
	if err != nil {
		return nil, nil, err
	}

	pipeline := &genericDeploymentPipeline{
		Stages: []genericPipelineStage{
			{
				Name: model.StageECSCanaryRollout,
				With: &config.ECSCanaryRolloutStageOptions{
					Scale: config.Percentage{
						// scale=trafficPercentage at first for the simpler configuration.
						Number: canaryTrafficPercent,
					},
				},
			},
			{
				Name: model.StageECSTrafficRouting,
				With: &config.ECSTrafficRoutingStageOptions{
					Canary: config.Percentage{
						Number: canaryTrafficPercent,
					},
				},
			},
			{
				// The simplest analysis stage, just waiting for 30 seconds.
				// The purpose is to let users know AnalysisStage and adopt Progressive Delivery without human operations.
				Name: model.StageAnalysis,
				With: &config.AnalysisStageOptions{
					Duration: config.Duration(60 * time.Second),
				},
			},
			{
				Name: model.StageECSPrimaryRollout,
			},
			{
				Name: model.StageECSTrafficRouting,
				With: &config.ECSTrafficRoutingStageOptions{
					Primary: config.Percentage{
						Number: 100,
					},
				},
			},
			{
				Name: model.StageECSCanaryClean,
			},
		},
	}

	return &deploymentInput, pipeline, nil
}

func inputBlueGreen(p *prompt.Prompt) (*config.ECSDeploymentInput, *genericDeploymentPipeline, error) {
	// target groups configs
	primaryTarget, err := inputTargetGroup(p, "(primary TaskSet)")
	if err != nil {
		return nil, nil, err
	}

	canaryTarget, err := inputTargetGroup(p, "(canary TaskSet)")
	if err != nil {
		return nil, nil, err
	}

	deploymentInput := config.ECSDeploymentInput{
		TargetGroups: config.ECSTargetGroups{
			Primary: primaryTarget,
			Canary:  canaryTarget,
		},
	}

	pipeline := &genericDeploymentPipeline{
		Stages: []genericPipelineStage{
			{
				Name: model.StageECSCanaryRollout,
				With: &config.ECSCanaryRolloutStageOptions{
					Scale: config.Percentage{
						Number: 100,
					},
				},
			},
			{
				Name: model.StageECSTrafficRouting,
				With: &config.ECSTrafficRoutingStageOptions{
					Canary: config.Percentage{
						Number: 100,
					},
				},
			},
			{
				// The simplest analysis stage, just waiting for 30 seconds.
				// The purpose is to let users know AnalysisStage and adopt Progressive Delivery without human operations.
				Name: model.StageAnalysis,
				With: &config.AnalysisStageOptions{
					Duration: config.Duration(60 * time.Second),
				},
			},
			{
				Name: model.StageECSPrimaryRollout,
			},
			{
				Name: model.StageECSTrafficRouting,
				With: &config.ECSTrafficRoutingStageOptions{
					Primary: config.Percentage{
						Number: 100,
					},
				},
			},
			{
				Name: model.StageECSCanaryClean,
			},
		},
	}

	return &deploymentInput, pipeline, nil
}

func inputTargetGroup(p *prompt.Prompt, annotation string) (*config.ECSTargetGroup, error) {
	var (
		targetGroupArn string
		containerName  string
		containerPort  int
	)

	inputs := []prompt.Input{
		{
			Message:       fmt.Sprintf("ARN of the target group to the service %s", annotation),
			TargetPointer: &targetGroupArn,
			Required:      false,
		},
		{
			Message:       fmt.Sprintf("Name of the container of the target group %s", annotation),
			TargetPointer: &containerName,
			Required:      false,
		},
		{
			Message:       fmt.Sprintf("Port number of the container of the target group %s", annotation),
			TargetPointer: &containerPort,
			Required:      false,
		},
	}

	err := p.RunSlice(inputs)
	if err != nil {
		return nil, err
	}

	return &config.ECSTargetGroup{
		TargetGroupArn: targetGroupArn,
		ContainerName:  containerName,
		ContainerPort:  containerPort,
	}, nil
}
